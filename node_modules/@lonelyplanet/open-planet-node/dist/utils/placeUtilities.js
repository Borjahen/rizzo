"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mapper_1 = require("../resources/place/mapper");
var place_1 = require("../resources/place");
var placeMapper = new mapper_1.PlaceMapper();
var ancestryList = function (ancestry) { return Array.isArray(ancestry) ? ancestry : [ancestry]; };
function assignContainingPlaces(included, ancestry, model) {
    model.containingPlaces = ancestry.reduce(function (acc, curr) {
        var ancestor = included.find(function (i) { return i.id === curr.id; });
        if (ancestor) {
            acc.push(placeMapper.toModel(ancestor));
        }
        return acc;
    }, []);
}
exports.assignContainingPlaces = assignContainingPlaces;
var capitalize = function (string) {
    return "" + string[0].toUpperCase() + string.slice(1);
};
var getPlaces = function (included, ancestry) {
    return included.filter(function (resource) { return resource.type === place_1.placeType && ancestryList(ancestry).some(function (p) { return p.id === resource.id; }); });
};
var createPlaceTypeAssigner = function (type, // any place type that a given POI will possess one of (see "assignRegions" below)
assignments, // will check for these keys on both `result` and `result.attributes` & assign value if found.
ifFound) {
    if (assignments === void 0) { assignments = ["id", "name"]; }
    if (ifFound === void 0) { ifFound = function () { return null; }; }
    return function (included, ancestry, place, model) {
        var places = getPlaces(included, ancestry);
        var result = place.attributes.place_type === type ?
            place :
            places.find(function (p) { return p.attributes.place_type === type; });
        if (result) {
            Object.assign(model, assignments.reduce(function (acc, assignment) {
                var assignmentKey = "containing" + capitalize(type) + capitalize(assignment); // e.g. "containingCityName", "containingNeighborhoodId".
                var assignmentValue = result[assignment] || result.attributes && result.attributes[assignment];
                return __assign({}, acc, (_a = {}, _a[assignmentKey] = assignmentValue, _a));
                var _a;
            }, {}));
            ifFound(result, model);
        }
    };
};
exports.assignRegions = function (included, ancestry, place, model) {
    /**
     * Special case for regions, as there seem to be multiple for a given POI.
     */
    var places = getPlaces(included, ancestry);
    var regions = place.attributes.place_type === "region" ?
        [place] :
        places.filter(function (p) { return p.attributes.place_type === "region"; });
    var regionNames = regions.map(function (_a) {
        var attributes = _a.attributes;
        return attributes.name;
    });
    if (regionNames.length > 0) {
        model.containingRegionNames = regionNames;
    }
};
exports.assignCity = createPlaceTypeAssigner("city");
exports.assignContinent = createPlaceTypeAssigner("continent");
exports.assignCountry = createPlaceTypeAssigner("country", ["name"], function (result, model) {
    if (model.telephone) {
        model.telephone.callingCode = "+" + result.attributes.calling_code;
    }
    if (model.poi && model.poi.telephone) {
        model.poi.telephone.callingCode = "+" + result.attributes.calling_code;
    }
});
exports.assignNeighborhood = createPlaceTypeAssigner("neighborhood");

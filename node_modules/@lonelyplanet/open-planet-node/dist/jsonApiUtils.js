"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var encodeFilterValues = function (value) {
    return value
        .split(",")
        .map(function (segment) {
        // decode first to allow client to send raw or encoded
        var decoded = decodeURIComponent(segment);
        return encodeURIComponent(decoded);
    })
        .join(",");
};
var excludeKeys = [
    "include",
    "resource",
    "sort",
    "limit",
    "offset",
    "extras",
    "nocache"
];
function createFilters(options) {
    var resource = options.resource;
    var filters = Object.keys(options).reduce(function (memo, key) {
        if (excludeKeys.indexOf(key) === -1) {
            var optionsType = typeof options[key];
            if (optionsType === "object") {
                // determine third filter value based on object keys
                var base_1 = "filter" + (resource ? "[" + resource + "]" : "") + "[" + key + "]";
                var filterObject_1 = options[key];
                var filters_1 = Object.keys(filterObject_1).map(function (k) {
                    var filterValue = filterObject_1[k];
                    if (typeof filterValue === "string") {
                        filterValue = encodeFilterValues(filterObject_1[k]);
                    }
                    return base_1 + "[" + k + "]=" + filterValue;
                });
                memo.push(filters_1.join("&"));
            }
            else {
                // fallback to equals if a simple string value
                var filterType = "equals";
                var filterValue = optionsType === "string"
                    ? encodeFilterValues(options[key])
                    : options[key];
                memo.push("filter" + (resource ? "[" + resource + "]" : "") + "[" + key + "][" + filterType + "]=" + filterValue);
            }
        }
        return memo;
    }, []);
    if (options.extras) {
        filters.push(Object.keys(options.extras)
            .reduce(function (memo, key) {
            memo.push(key + "=" + options.extras[key]);
            return memo;
        }, [])
            .join("&"));
    }
    if (options.sort) {
        filters.push("sort=" + options.sort);
    }
    if (options.limit) {
        filters.push("page[limit]=" + options.limit);
    }
    if (options.offset) {
        filters.push("page[offset]=" + options.offset);
    }
    return filters.join("&");
}
exports.createFilters = createFilters;
function createIncludes(include) {
    var includeString = Array.isArray(include) ? include.join(",") : include;
    return include ? "include=" + includeString : "";
}
exports.createIncludes = createIncludes;
function createFindByIdUrl(url, id, options) {
    if (options === void 0) { options = {}; }
    var include = createIncludes(options.include);
    var noCache = "";
    if (options.nocache) {
        noCache = "nocache=true";
    }
    var idFilters = "";
    if (Array.isArray(id)) {
        idFilters = "filter[" + options.resource + "][id][equals]=" + id.join(",");
        idFilters += "&page[limit]=" + id.length;
    }
    var filters = createFilters(__assign({ resource: options.resource || this.resource }, options));
    var query = [include, noCache, idFilters, filters].filter(function (f) { return f; }).join("&");
    if (query.length) {
        url += "?" + query;
    }
    return url;
}
exports.createFindByIdUrl = createFindByIdUrl;

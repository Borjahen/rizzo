import { injectable } from "inversify";
import VideoPlaylistItem, { IVideoPlaylistItem, IVideoPlaylistItemResource, videoPlaylistItemType } from "./";
import { IJsonApiRelationshipResource, IJsonApiResource } from "../../interfaces";
import Mapper from "../../mapper";
import VideoMapper from "../video/mapper";
import { videoType } from "../video";

@injectable()
export class VideoPlaylistItemMapper extends Mapper<IVideoPlaylistItem, IVideoPlaylistItemResource> {

  private videoMapper = new VideoMapper();

  toModel(resource: IVideoPlaylistItemResource, included: IJsonApiResource[] = []): IVideoPlaylistItem {
    const model = new VideoPlaylistItem();
    const { relationships, attributes: attrs } = resource;

    model.id = resource.id;
    model.createdAt = attrs.create_date;
    model.order = attrs.order;

    if (relationships && relationships.video && relationships.video.data) {
      const data = relationships.video.data as IJsonApiRelationshipResource;
      const includedResource = included.find((i) => i.type === videoType && i.id === data.id);
      if (includedResource) {
        model.video = this.videoMapper.toModel(includedResource, included);
      } else {
        model.video = data;
      }
    }

    return model;
  }

  toResource(model: IVideoPlaylistItem): IVideoPlaylistItemResource {
    const resource: IVideoPlaylistItemResource = {
      id: model.id,
      type: videoPlaylistItemType,
      attributes: {
        order: model.order
      },
      relationships: {
        video: {
          data: null,
        }
      },
    };

    if (model.video) {
      resource.relationships.video.data = {
        id: model.video.id,
        type: videoType,
      }
    }

    Object.keys(resource.attributes).forEach((key) => {
      if (typeof resource.attributes[key] === "undefined") {
        delete resource.attributes[key];
      }
    });

    if (Object.keys(resource.relationships).length === 0) {
      delete resource.relationships;
    }

    return resource;
  }
}

export default VideoMapper;

import { inject, injectable } from "inversify";
import Product, { IProduct, IProductResource, IProductAttributes, productType, IProductPrice } from "./";
import { IJsonApiResource } from "../../interfaces";
import Mapper from "../../mapper";
import * as TYPES from "../../types";
import imgix from "../../utils/imgix";

@injectable()
export class ProductMapper extends Mapper<IProduct, IProductResource> {
  toModel(resource: IProductResource, included: IJsonApiResource[] = []): IProduct {
    const model = new Product();
    const attrs = resource.attributes;

    model.id = resource.id;
    model.authors = attrs.authors;
    model.category = attrs.category;
    model.descriptions.longDescription = attrs.descriptions.long_description;
    model.descriptions.shortDescription = attrs.descriptions.short_description;
    model.edition = attrs.edition;
    model.images.original = attrs.images.original;
    if (attrs.images.small && Array.isArray(attrs.images.small)) {
      model.images.small = attrs.images.small;
    }
    if (attrs.images.medium && Array.isArray(attrs.images.medium)) {
      model.images.medium = attrs.images.medium;
    }
    if (attrs.images.large && Array.isArray(attrs.images.large)) {
      model.images.large = attrs.images.large;
    }
    model.isBundle = attrs.is_bundle;
    model.isChapter = attrs.is_chapter;
    model.isDigital = attrs.digital;
    model.isbn = attrs.isbn;
    model.pageColourCount = attrs.page_colour_count;
    model.pageCount = attrs.page_count;
    model.pageMapsCount = attrs.page_maps_count;
    model.productType = attrs.product_type;
    model.releaseDate = new Date(attrs.release_date);
    model.score = attrs.score;
    model.title = attrs.title;
    model.shop = resource.links.shop;

    const priceToModelPrice = (price: any = {}) => ({
      amount: price.amount,
      currency: price.currency,
    });

    if (attrs.pricing && Array.isArray(attrs.pricing)) {
      model.pricing = attrs.pricing.map(priceToModelPrice);
    }

    const places = (<IJsonApiResource[]>resource.relationships["places"].data);

    if (places && places.length) {
      model.containingPlaceIds = places.map((place) => place.id);
    }

    return model;
  }

  toResource(model: IProduct): IProductResource {
    const modelPriceToResourcePrice = (price) => ({
      amount: price.amount,
      currency: price.currency,
    });
    const resource = {
      id: model.id,
      type: productType,
      attributes: {
        authors: model.authors,
        category: model.category,
        descriptions: {
          long_description: model.descriptions.longDescription,
          short_description: model.descriptions.shortDescription,
        },
        digital: model.isDigital,
        edition: model.edition,
        images: {
          original: model.images.original,
          small: model.images.small,
          medium: model.images.medium,
          large: model.images.large,
        },
        is_bundle: model.isBundle,
        is_chapter: model.isChapter,
        isbn: model.isbn,
        page_colour_count: model.pageColourCount,
        page_count: model.pageCount,
        page_maps_count: model.pageMapsCount,
        pricing: model.pricing.map(modelPriceToResourcePrice),
        product_type: model.productType,
        release_date: model.releaseDate.toISOString().toString(),
        score: model.score,
        title: model.title,
      },
    };

    return resource;
  }
}

export default ProductMapper;

import * as nock from "nock";
import HttpClient from "../http";
import JsonApiError from "../jsonApiError";

describe("http", () => {
  it("should send json api content-type header", async () => {
    const mockReponse = { success: "true" };
    const fetchMock = nock("http://www.lp.com", {
      reqheaders: {
        "content-type": "application/vnd.api+json",
      },
    })
    .get("/test")
    .reply(200, mockReponse);

    const client = new HttpClient();
    const response = await client.fetch("http://www.lp.com/test");
    fetchMock.done();

    expect(response).toEqual(mockReponse);
  });

  it("should send trace token", async () => {
    const mockReponse = { success: "true" };
    const fetchMock = nock("http://www.lp.com", {
      reqheaders: {
        "x-trace-token": (value) => !!value,
      },
    })
    .get("/test")
    .reply(200, mockReponse);

    const client = new HttpClient();
    const response = await client.fetch("http://www.lp.com/test");
    fetchMock.done();

    expect(response).toEqual(mockReponse);
  });

  it("should return void when status code is 204", async () => {
    const fetchMock = nock("http://www.lp.com")
      .post("/test")
      .reply(204);

    const client = new HttpClient();
    const requestOptions = {
      method: "post",
    };
    const response = await client.fetch("http://www.lp.com/test", requestOptions);
    fetchMock.done();

    expect(response).toBeUndefined();
  });

  it("should fail when status code is 3xx", async () => {
    const fetchMock = nock("http://www.lp.com")
      .get("/test")
      .reply(303);

    const client = new HttpClient();
    let failed = false;
    try {
      await client.fetch("http://www.lp.com/test");
    } catch (err) {
      failed = true;
    }

    fetchMock.done();
    expect(failed).toBeTruthy();
  });

  it("should fail when status code is 4xx", async () => {
    const fetchMock = nock("http://www.lp.com")
      .get("/test")
      .reply(404);

    const client = new HttpClient();
    let failed = false;
    try {
      await client.fetch("http://www.lp.com/test");
    } catch (err) {
      failed = true;
    }

    fetchMock.done();
    expect(failed).toBeTruthy();
  });

  it("should fail when status code is 5xx", async () => {
    const fetchMock = nock("http://www.lp.com")
      .get("/test")
      .reply(502);

    const client = new HttpClient();
    let failed = false;
    try {
      await client.fetch("http://www.lp.com/test");
    } catch (err) {
      failed = true;
    }

    fetchMock.done();
    expect(failed).toBeTruthy();
  });

  it("should return body as text on DELETE requests", async () => {
    const mockResponse = "string response";
    const fetchMock = nock("http://www.lp.com")
      .delete("/test")
      .reply(200, mockResponse);

    const client = new HttpClient();
    const requestOptions = {
      method: "delete",
    };
    const response = await client.fetch("http://www.lp.com/test", requestOptions);
    fetchMock.done();

    expect(response).toBe(mockResponse);
  });

  it("should parse the first json api error on error response", async () => {
    const error = {
      id: "error-id",
      status: "404",
      code: "not_found",
      title: "Not Found",
      detail: "The requested bookmark list was not found",
      source: {
        pointer: "/data/id",
      },
    };
    const fetchMock = nock("http://www.lp.com")
      .get("/test")
      .reply(404, {
        errors: [error, {
          id: "second_error"
        }]
      });

    const client = new HttpClient();
    let caughtError;
    try {
      await client.fetch("http://www.lp.com/test");
    } catch (err) {
      caughtError = err;
    }

    fetchMock.done();
    expect(caughtError).toBeDefined();
    expect(caughtError).toBeInstanceOf(JsonApiError);
    expect(caughtError.id).toBe(error.id);
    expect(caughtError.status).toBe(error.status);
    expect(caughtError.code).toBe(error.code);
    expect(caughtError.title).toBe(error.title);
    expect(caughtError.detail).toBe(error.detail);
    expect(caughtError.source).toBeDefined();
    expect(caughtError.source.pointer).toBe(error.source.pointer);
  });
});

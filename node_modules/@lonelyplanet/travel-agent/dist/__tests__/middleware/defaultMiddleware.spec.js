"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var staticMock = jest.fn();
var routerMock = jest.fn(function () { return ({ get: jest.fn() }); });
jest.mock("express", function () { return ({
    static: staticMock,
    Router: routerMock,
}); });
var AirbrakeClientMock = jest.fn();
jest.mock("airbrake-js", function () { return AirbrakeClientMock; });
var AirbrakeCredsMock = jest.fn();
jest.mock("../../classes/airbrakeCreds", function () { return ({
    default: AirbrakeCredsMock,
}); });
var makeErrorHandlerMock = jest.fn();
jest.mock("airbrake-js/dist/instrumentation/express", function () { return makeErrorHandlerMock; });
var errorHandlerMock = jest.fn();
jest.mock("../../middleware/errorHandler", function () { return ({
    default: errorHandlerMock,
}); });
var catchAllMock = jest.fn();
jest.mock("../../middleware/catchAll", function () { return ({ default: catchAllMock }); });
var setLocationMock = jest.fn();
jest.mock("../../middleware/setLocation", function () { return ({ default: setLocationMock }); });
var handleFaviconMock = jest.fn();
jest.mock("../../middleware/handleFavicon", function () { return ({
    default: handleFaviconMock,
}); });
var defaultMiddleware_1 = require("../../middleware/defaultMiddleware");
describe("defaultMiddleware", function () {
    describe("defaultMiddleware", function () {
        var urlencodedMock;
        var jsonMock;
        var req;
        beforeEach(function () {
            urlencodedMock = jest.fn();
            jsonMock = jest.fn();
            req = jest
                .fn()
                .mockImplementationOnce(function (pkg) { return function () { return "helmet"; }; })
                .mockImplementationOnce(function (pkg) { return ({
                urlencoded: urlencodedMock,
            }); })
                .mockImplementationOnce(function (pkg) { return function () { return "cookie-parser"; }; })
                .mockImplementationOnce(function (pkg) { return function () { return "cors"; }; })
                .mockImplementationOnce(function (pkg) { return ({ json: jsonMock }); });
        });
        afterEach(function () {
            urlencodedMock.mockReset();
            jsonMock.mockReset();
            req.mockReset();
            setLocationMock.mockReset();
            handleFaviconMock.mockReset();
            routerMock.mockReset();
        });
        it("should return the default middleware", function () {
            var middleware = defaultMiddleware_1.defaultMiddleware({}, req);
            expect(middleware.length).toBe(8);
            expect(middleware[5]).toEqual(setLocationMock);
            expect(middleware[6]).toEqual(handleFaviconMock);
            expect(req).toHaveBeenCalledWith("helmet");
            expect(req).toHaveBeenCalledWith("body-parser");
            expect(req).toHaveBeenCalledWith("cookie-parser");
            expect(req).toHaveBeenCalledWith("cors");
            expect(urlencodedMock).toHaveBeenCalledTimes(1);
            expect(urlencodedMock).toHaveBeenCalledWith({ extended: false });
            expect(jsonMock).toHaveBeenCalledTimes(1);
        });
    });
    describe("defaultDevMiddleware", function () {
        var config;
        var compiler;
        var webpack;
        var webpackHotMiddleware;
        var webpackDevMiddleware;
        var req;
        beforeEach(function () {
            config = { entry: "path/index.js" };
            compiler = { compiler: true };
            webpack = jest.fn(function (config) { return compiler; });
            webpackHotMiddleware = jest.fn(function (compiler) { return "webpack-hot-middleware middleware"; });
            webpackDevMiddleware = jest.fn(function (compiler, options) { return "webpack-dev-middleware middleware"; });
            req = jest
                .fn()
                .mockImplementationOnce(function (pkg) { return function (env) {
                return pkg + "-" + env + " middleware";
            }; })
                .mockImplementationOnce(function (pkg) { return webpack; })
                .mockImplementationOnce(function (path) { return ({ default: config }); })
                .mockImplementationOnce(function (pkg) { return webpackHotMiddleware; })
                .mockImplementationOnce(function (pkg) { return webpackDevMiddleware; });
            staticMock.mockImplementation(function (pkg) { return "express static middleware"; });
        });
        afterEach(function () {
            webpack.mockReset();
            webpackHotMiddleware.mockReset();
            webpackDevMiddleware.mockReset();
            req.mockReset();
            staticMock.mockReset();
        });
        it("should return the dev middleware (without webpack)", function () {
            var middleware = defaultMiddleware_1.defaultDevMiddleware({}, req);
            expect(middleware).toEqual([
                "express static middleware",
                "morgan-dev middleware",
            ]);
        });
        it("should not return morgan if logging is explicitly disabled", function () {
            var middleware = defaultMiddleware_1.defaultDevMiddleware({ disableDefaultLoggingMiddleware: true }, req);
            expect(middleware).not.toContain(["morgan-dev middleware"]);
        });
        it("should return the dev middleware (with webpack)", function () {
            var middleware = defaultMiddleware_1.defaultDevMiddleware({ webpack: true }, req);
            expect(webpack).toHaveBeenCalledWith(config);
            expect(webpackHotMiddleware).toHaveBeenCalledWith(compiler);
            expect(webpackDevMiddleware).toHaveBeenCalledWith(compiler, {
                noInfo: true,
                publicPath: "/assets/",
                serverSideRender: true,
            });
            expect(middleware).toEqual([
                "express static middleware",
                "morgan-dev middleware",
                "webpack-hot-middleware middleware",
                "webpack-dev-middleware middleware",
            ]);
        });
    });
    describe("defaultProductionMiddleware", function () {
        var expressBunyanLoggerMock;
        var req;
        beforeEach(function () {
            expressBunyanLoggerMock = jest.fn(function () { return "express-bunyan-logger middleware"; });
            req = jest
                .fn()
                .mockImplementationOnce(function (pkg) { return expressBunyanLoggerMock; });
            staticMock.mockImplementation(function (path) { return "express static middleware"; });
        });
        afterEach(function () {
            expressBunyanLoggerMock.mockReset();
            req.mockReset();
            staticMock.mockReset();
        });
        it("should return the production middleware (without options or name)", function () {
            var middleware = defaultMiddleware_1.defaultProductionMiddleware({}, null, req);
            expect(expressBunyanLoggerMock.mock.calls[0]).toMatchSnapshot();
            expect(middleware.length).toBe(1);
            expect(middleware).toEqual(["express-bunyan-logger middleware"]);
        });
        it("should not return bunyan in production middleware if logging is disabled", function () {
            var middleware = defaultMiddleware_1.defaultProductionMiddleware({ disableDefaultLoggingMiddleware: true }, null, req);
            expect(middleware).not.toContain(["express-bunyan-logger middleware"]);
        });
        it("should return the production middleware (with options and name)", function () {
            var middleware = defaultMiddleware_1.defaultProductionMiddleware({ serveAssets: true }, "lp-service-id", req);
            expect(expressBunyanLoggerMock.mock.calls[0][0].name).toBe("lp-service-id");
            expect(middleware.length).toBe(2);
            expect(middleware).toEqual([
                "express-bunyan-logger middleware",
                "express static middleware",
            ]);
        });
    });
    describe("defaultPostMiddleware", function () {
        beforeEach(function () {
            AirbrakeCredsMock.mockImplementation(function (airbrakeId, airbrakeKey) { return ({
                airbrakeId: airbrakeId,
                airbrakeKey: airbrakeKey,
            }); });
            errorHandlerMock.mockImplementation(function () { return "errorHandler middleware"; });
            makeErrorHandlerMock.mockImplementation(function () { return "makeErrorHandler middleware"; });
        });
        afterEach(function () {
            AirbrakeClientMock.mockReset();
            AirbrakeCredsMock.mockReset();
            errorHandlerMock.mockReset();
            makeErrorHandlerMock.mockReset();
        });
        it("should return the middleware for the dev environment", function () {
            var options = { sendProductionErrors: false };
            var middleware = defaultMiddleware_1.defaultPostMiddleware(false, options);
            expect(errorHandlerMock).toHaveBeenCalledWith(false, options);
            expect(middleware).toEqual([catchAllMock, "errorHandler middleware"]);
        });
        it("should return the middleware for the prod environment", function () {
            var options = {
                sendProductionErrors: false,
                airbrakeId: "abc",
                airbrakeKey: "xyz",
            };
            var middleware = defaultMiddleware_1.defaultPostMiddleware(true, options);
            expect(AirbrakeCredsMock).toHaveBeenCalledWith("abc", "xyz");
            expect(AirbrakeClientMock).toHaveBeenCalledWith({
                projectId: "abc",
                projectKey: "xyz",
            });
            expect(makeErrorHandlerMock).toHaveBeenCalledTimes(1);
            expect(errorHandlerMock).toHaveBeenCalledWith(true, {
                sendProductionErrors: false,
            });
            expect(middleware).toEqual([
                "makeErrorHandler middleware",
                catchAllMock,
                "errorHandler middleware",
            ]);
        });
        it("should return the middleware for the prod environment (with `production` key)", function () {
            var options = {
                sendProductionErrors: false,
                production: {
                    airbrakeId: "abc",
                    airbrakeKey: "xyz",
                },
            };
            var middleware = defaultMiddleware_1.defaultPostMiddleware(true, options);
            expect(AirbrakeCredsMock).toHaveBeenCalledWith("abc", "xyz");
            expect(AirbrakeClientMock).toHaveBeenCalledWith({
                projectId: "abc",
                projectKey: "xyz",
            });
            expect(makeErrorHandlerMock).toHaveBeenCalledTimes(1);
            expect(errorHandlerMock).toHaveBeenCalledWith(true, {
                sendProductionErrors: false,
            });
            expect(middleware).toEqual([
                "makeErrorHandler middleware",
                catchAllMock,
                "errorHandler middleware",
            ]);
        });
        it("should return the middleware for the prod environment (with `production` key that only has the id)", function () {
            var options = {
                sendProductionErrors: false,
                production: {
                    airbrakeId: "abc",
                },
            };
            var middleware = defaultMiddleware_1.defaultPostMiddleware(true, options);
            expect(AirbrakeCredsMock).toHaveBeenCalledWith("abc", undefined);
            expect(AirbrakeClientMock).toHaveBeenCalledTimes(0);
            expect(makeErrorHandlerMock).toHaveBeenCalledTimes(0);
            expect(errorHandlerMock).toHaveBeenCalledWith(true, {
                sendProductionErrors: false,
            });
            expect(middleware).toEqual([catchAllMock, "errorHandler middleware"]);
        });
        it("should return the middleware for the prod environment (without airbrake data)", function () {
            var options = {
                sendProductionErrors: false,
            };
            var middleware = defaultMiddleware_1.defaultPostMiddleware(true, options);
            expect(AirbrakeCredsMock).toHaveBeenCalledTimes(1);
            expect(AirbrakeClientMock).toHaveBeenCalledTimes(0);
            expect(makeErrorHandlerMock).toHaveBeenCalledTimes(0);
            expect(errorHandlerMock).toHaveBeenCalledWith(true, {
                sendProductionErrors: false,
            });
            expect(middleware).toEqual([catchAllMock, "errorHandler middleware"]);
        });
    });
});

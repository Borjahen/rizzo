"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debugMock = jest.fn();
jest.mock("../../utils/logger", function () { return ({
    default: { debug: debugMock },
}); });
var errorHandler_1 = require("../../middleware/errorHandler");
describe("errorHandler", function () {
    var renderMock;
    var jsonMock;
    var statusMock;
    beforeEach(function () {
        renderMock = jest.fn();
        jsonMock = jest.fn();
        statusMock = jest.fn();
    });
    afterEach(function () {
        renderMock.mockReset();
        jsonMock.mockReset();
        statusMock.mockReset();
        debugMock.mockReset();
    });
    it("should call next if headers are already sent", function () {
        var error = new Error("Foobar error");
        var nextMock = jest.fn();
        var isProdEnv = true;
        errorHandler_1.default(isProdEnv)(error, {
            headers: {},
        }, {
            headersSent: true,
        }, nextMock);
        expect(nextMock).toHaveBeenCalledWith(error);
    });
    it("should have a default error handler for dev", function () {
        var error = {
            message: "Foobar error",
            stack: "Error: Foobar error stack",
        };
        var isProdEnv = false;
        errorHandler_1.default(isProdEnv)(error, {
            headers: {},
        }, {
            json: jsonMock,
            render: renderMock,
            status: statusMock,
        }, {});
        expect(statusMock).toHaveBeenCalledWith(500);
        expect(debugMock).toHaveBeenCalledWith(error);
        expect(renderMock).toHaveBeenCalledWith("error", {
            error: error,
            message: "Foobar error",
            stack: "Error: Foobar error stack",
        });
    });
    it("should have a default error handler for production (without options)", function () {
        var error = {
            message: "Foobar error",
            stack: "Error: Foobar error stack",
            status: "Error status",
        };
        var isProdEnv = true;
        errorHandler_1.default(isProdEnv)(error, {
            headers: {},
        }, {
            json: jsonMock,
            render: renderMock,
            status: statusMock,
        }, {});
        expect(statusMock).toHaveBeenCalledWith("Error status");
        expect(debugMock).toHaveBeenCalledTimes(0);
        expect(renderMock).toHaveBeenCalledWith("error", {
            error: {},
            message: "An error has occurred",
        });
    });
    it("should have a default error handler for production (with options)", function () {
        var error = {
            message: "Foobar error",
            stack: "Error: Foobar error stack",
            status: "Error status",
        };
        var options = { sendProductionErrors: true };
        var isProdEnv = true;
        errorHandler_1.default(isProdEnv, options)(error, {
            headers: {},
        }, {
            json: jsonMock,
            render: renderMock,
            status: statusMock,
        }, {});
        expect(statusMock).toHaveBeenCalledWith("Error status");
        expect(debugMock).toHaveBeenCalledTimes(0);
        expect(renderMock).toHaveBeenCalledWith("error", {
            error: error,
            message: "Foobar error",
        });
    });
    it("should have a default error handler for dev (with json content type)", function () {
        var error = {
            message: "Foobar error",
            stack: "Error: Foobar error stack",
        };
        var isProdEnv = false;
        errorHandler_1.default(isProdEnv)(error, {
            headers: { "content-type": "application/json" },
        }, {
            json: jsonMock,
            render: renderMock,
            status: statusMock,
        }, {});
        expect(statusMock).toHaveBeenCalledWith(500);
        expect(debugMock).toHaveBeenCalledWith(error);
        expect(jsonMock).toHaveBeenCalledWith({
            error: error,
            message: "Foobar error",
            stack: "Error: Foobar error stack",
        });
    });
});

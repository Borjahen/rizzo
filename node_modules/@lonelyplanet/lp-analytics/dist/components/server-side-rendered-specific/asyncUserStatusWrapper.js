"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tracker_1 = require("../../tracker");
var config_json_1 = __importDefault(require("../../config.json"));
var analyticsPath = config_json_1.default.analyticsPath, globalPropsScopeName = config_json_1.default.globalPropsScopeName;
var normalizedAnalyticsPath = analyticsPath.split(".")[0] === "window" ? analyticsPath : "window." + analyticsPath;
exports.defaultAuthUrl = "https://connect.lonelyplanet.com";
exports.asyncUserStatusWrapper = function (content, callbackName, authUrl) {
    if (callbackName === void 0) { callbackName = "asyncUserStatusWrapperOnLoad"; }
    if (authUrl === void 0) { authUrl = exports.defaultAuthUrl; }
    /**
     * Important Notes:
     * 1. Anything else that will be present in the payload should be added prior to running this.
     * 2. Don't use the gtm.js snippet in conjunction with this (ie, <TrackingContainersInitializer>);
     *    we have to include its code _here_ as part of this script so that we can delay it
     *    until asynchronous resolution of user auth status has occurred.
     * 3. This will save the data it finds to `window.${globalPropsScopeName}` for compatibility
     *    with global-ui (specifically the global header); components requiring authentication
     *    will retrieve this instead of making another call (assuming they don't have it already).
     *    You won't need to add any additional code to make that happen. If the global header is not active,
     *    rizzo-next's header _will_ make another call (until/unless it is updated, which doesn't seem worth doing).
     */
    return "\n    (function() {\n      var invoked = \"asyncUserStatusWrapperHasBeenInvoked\";\n      var populateDataLayerAndInitializeContainer = function() {\n        " + content + "\n        " + tracker_1.makeTracker().snippet + "\n      };\n\n      window[\"" + callbackName + "\"] = function(user) {\n        if (user) {\n          window." + globalPropsScopeName + " = window." + globalPropsScopeName + " || {};\n          window." + globalPropsScopeName + ".auth = window." + globalPropsScopeName + ".auth || {\n            isUserSignedIn: !!user.id,\n            user: user\n          };\n        }\n        populateDataLayerAndInitializeContainer();\n        delete window[\"" + callbackName + "\"];\n      }\n\n      \"" + analyticsPath + "\".replace(\"window.\", \"\").split(\".\").reduce(\n        function(acc, key) {\n          return acc[key] || (acc[key] = {});\n        },\n        window\n      );\n\n      if (!" + normalizedAnalyticsPath + "[invoked]) {\n        var script = document.createElement('script');\n        script.src = \"" + authUrl + "/users/status.json?callback=" + callbackName + "\";\n        document.getElementsByTagName('head')[0].appendChild(script);\n        " + normalizedAnalyticsPath + "[invoked] = true;\n      }\n    })();\n  ";
};
exports.makeAsyncUserStatusWrapper = function (authUrl) {
    /**
     * This will return a function that you can use in place of `asyncUserStatusWrapper`, with a value
     * bound to `authUrl`. This will allow you to use environment variables in the host codebase
     * in order to specify QA/staging/production urls.
     */
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return exports.asyncUserStatusWrapper(args[0], args[1], authUrl);
    };
};

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var config_json_1 = __importDefault(require("../config.json"));
var dataLayer_1 = require("../dataLayer");
var testEvents_1 = require("../events/testEvents");
var gtmDataLayerName = config_json_1.default.providers.googleTagManager.gtmDataLayerName;
describe("getDataLayer function", function () {
    beforeEach(function () {
        delete window.dataLayer;
    });
    it("should affix an appropriately named dataLayer array to the window, and return a reference to it", function () {
        var result = dataLayer_1.getDataLayer("");
        expect(result).toEqual([]);
        expect(window.dataLayer).toBe(result);
    });
    it("should work the same way whether or not the path is preceded by 'window'", function () {
        var result = dataLayer_1.getDataLayer("window");
        expect(result).toEqual([]);
        expect(window.dataLayer).toBe(result);
    });
    it("should be able to create nested objects ending in a dataLayer array", function () {
        var result = dataLayer_1.getDataLayer("planet.frontend.stuff");
        expect(result).toEqual([]);
        expect(window.planet.frontend.stuff.dataLayer).toBe(result);
    });
    it("should return consistent references to the data layer array", function () {
        var firstReference = dataLayer_1.getDataLayer("myDataLayer");
        var secondReference = dataLayer_1.getDataLayer("myDataLayer");
        expect(firstReference).toBe(secondReference);
        expect(firstReference).toBe(window.myDataLayer.dataLayer);
    });
    it("should retrieve, but not reset the dataLayer on subsequent calls", function () {
        dataLayer_1.getDataLayer("anotherTestLayer");
        window.anotherTestLayer.dataLayer.push("some data");
        var value = window.anotherTestLayer.dataLayer[0];
        expect(value).toBe("some data");
        // retrieve again.
        dataLayer_1.getDataLayer("anotherTestLayer");
        var updatedValue = window.anotherTestLayer.dataLayer[0];
        expect(updatedValue).toBe(value);
    });
    it("should not affect existing data in any object in its path, should any already exist", function () {
        window.lp = { reminder: "this was already here" };
        dataLayer_1.getDataLayer("lp.analytics");
        window.lp.analytics.dataLayer.push("some data");
        expect(window.lp.reminder).toBe("this was already here");
    });
    it("should ensure that window[gtmDataLayerName]\n    references the dataLayer retrieved or created at 'path' if it's an array", function () {
        var someDataLayer = dataLayer_1.getDataLayer("window");
        expect(window[gtmDataLayerName]).toBe(someDataLayer);
        var anotherDataLayer = dataLayer_1.getDataLayer("window.dataLayer");
        expect(window[gtmDataLayerName]).toBe(anotherDataLayer);
        var lastDataLayer = dataLayer_1.getDataLayer("window.another.one.called.dataLayer");
        expect(window[gtmDataLayerName]).toBe(lastDataLayer);
    });
    it("should return window[gtmDataLayerName] instead, which does _not_\n    alias the dataLayer retrieved at 'path', if that retrieved dataLayer is not an array", function () {
        /**
         * This is to ensure compatibility with Rizzo, where `window.lp.analytics.dataLayer` is an object. We'll want to
         * prevent aliasing to window[gtmDataLayerName] and instead abandon `window.lp.analytics.dataLayer` in favor of
         * window[gtmDataLayerName], which we will push to if *it* is an array (it should be, even in rizzo).
         */
        window.trying = {};
        window.trying.anObject = {};
        window.trying.anObject.dataLayer = {};
        var redirectedToArray = dataLayer_1.getDataLayer("window.trying.anObject");
        expect(typeof window.trying.anObject).toBe("object");
        expect(Array.isArray(redirectedToArray)).toBe(true);
        expect(window[gtmDataLayerName]).toBe(redirectedToArray);
    });
    it("in the scenario described above, window[gtmDataLayerName]\n    should be set to an empty array if it does not yet exist.", function () {
        expect(window[gtmDataLayerName]).toBeUndefined();
        window.anotherObject = {};
        dataLayer_1.getDataLayer("window.anotherObject");
        expect(window[gtmDataLayerName]).toEqual([]);
    });
});
describe("getTrackMethod function", function () {
    it("should similarly handle its own setup", function () {
        var result = dataLayer_1.getTrackMethod("some.stuff.on.the.window");
        expect(result).toBe(window.some.stuff.on.the.window.track);
    });
    it("should track events", function () {
        var dataLayer = dataLayer_1.getDataLayer("window.over.here");
        var trackMethod = dataLayer_1.getTrackMethod("window.over.here");
        trackMethod(testEvents_1.dataLayerInit);
        var pushed = dataLayer[0];
        expect(pushed).toBe(testEvents_1.dataLayerInit);
    });
    it("should work with a dataLayer attached to its parent object", function () {
        var otherDataLayer = dataLayer_1.getDataLayer("window.this.way");
        var trackMethod = dataLayer_1.getTrackMethod("window.that.way");
        trackMethod(testEvents_1.dataLayerInit);
        var notPushed = otherDataLayer[0];
        var pushed = window.that.way.dataLayer[0];
        expect(notPushed).toBeUndefined();
        expect(pushed).toBe(testEvents_1.dataLayerInit);
    });
});

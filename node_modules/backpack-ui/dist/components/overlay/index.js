"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactPortal = require("react-portal");

var _reactPortal2 = _interopRequireDefault(_reactPortal);

var _radium = require("radium");

var _radium2 = _interopRequireDefault(_radium);

var _colors = require("../../styles/colors");

var _colors2 = _interopRequireDefault(_colors);

var _timing = require("../../styles/timing");

var _timing2 = _interopRequireDefault(_timing);

var _zIndex = require("../../styles/zIndex");

var _zIndex2 = _interopRequireDefault(_zIndex);

var _color = require("../../utils/color");

var _propTypes3 = require("../../utils/propTypes");

var _propTypes4 = _interopRequireDefault(_propTypes3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var styles = {
  portal: {
    base: {
      height: 0,
      width: 0
    }
  },

  overlay: {
    base: {
      bottom: 0,
      height: "100vh",
      left: 0,
      position: "fixed",
      right: 0,
      top: 0,
      transitionProperty: "opacity"
    },

    hidden: {
      opacity: 0
    },

    visible: {
      opacity: 1
    }
  }
};

function Overlay(_ref) {
  var animationDuration = _ref.animationDuration,
      attached = _ref.attached,
      color = _ref.color,
      onClick = _ref.onClick,
      visible = _ref.visible,
      zIndex = _ref.zIndex,
      style = _ref.style;

  return _react2.default.createElement(
    _reactPortal2.default,
    {
      className: "Overlay-portal",
      key: "overlay",
      isOpened: attached || visible,
      style: styles.portal.base
    },
    _react2.default.createElement("div", { // eslint-disable-line jsx-a11y/no-static-element-interactions
      className: "Overlay",
      onClick: onClick,
      style: [styles.overlay.base, color && { backgroundColor: color }, animationDuration && { transitionDuration: animationDuration + "ms" }, zIndex && { zIndex: zIndex }, visible ? styles.overlay.visible : styles.overlay.hidden, style]
    })
  );
}

Overlay.propTypes = {
  /**
   * How long the animation should last, in ms
   */
  animationDuration: _propTypes2.default.number,

  /**
   * Whether or not the overlay has been attached to the DOM. This prop differs
   * from `visible` in that the overlay must be attached _before_ the overlay
   * is actually visible. This allows the animation to have time to run. To
   * create this offset, you'll need to use a setTimeout in the component in
   * which the overlay is called to stagger the state change. If no animation
   * is needed, then omit this prop and the value from `visible` will be used.
   */
  attached: _propTypes2.default.bool,

  /**
   * The color over the overlay; this prop assumes no opacity so you'll need to
   * pass in the correct value via `rgba`.
   */
  color: _propTypes2.default.string,

  /**
   * A method to run when the overlay is clicked, usually to close the overlay
   * and the component in which it was called from.
   */
  onClick: _propTypes2.default.func,

  /**
   * Whether or not the overlay is actually visible, not necessarily attached to
   * the DOM.
   */
  visible: _propTypes2.default.bool.isRequired,

  /**
   * Used to control where the overlay should be placed on the z-axis
   */
  zIndex: _propTypes2.default.number,

  /**
   * Apply custom styles
   */
  style: _propTypes4.default.style
};

Overlay.defaultProps = {
  animationDuration: parseInt(_timing2.default.default.replace("ms", ""), 10),
  attached: false,
  color: "rgba(" + (0, _color.rgb)(_colors2.default.bgOverlay) + ", .3)",
  onClick: null,
  visible: false,
  zIndex: _zIndex2.default.overlay,
  style: null
};

exports.default = (0, _radium2.default)(Overlay);